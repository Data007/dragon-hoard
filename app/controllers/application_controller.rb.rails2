# Filters added to this controller apply to all controllers in the application.
# Likewise, all the methods added will be available for all controllers.

class ApplicationController < ActionController::Base
  include SslRequirement
  
  helper :all # include all helpers, all the time
  protect_from_forgery # See ActionController::RequestForgeryProtection for details

  # Scrub sensitive parameters from your log
  filter_parameter_logging :fb_sig_friends, :password
  before_filter :refresh_current_user_session, :current_order
  # after_filter :save_previous_page
  # before_filter :force_login, :except => [:login, :authenticate, :logout]
  # before_filter :is_logged_in?, :prepare_title #, :prepare_session
  # before_filter :prepare_session
  
  rescue_from ActionController::RoutingError do
    redirect_to bad_route_path
  end
  
  private
    def current_page
      request.request_uri
    end

    def prepare_title
      @title = ": #{current_page}"
    end

    def pagination_hash
      {
        :page => ( params[:page] or 1 ),
        :per_page => ( params[:per_page] or 9 ),
        :order => "updated_at DESC"
      }
    end
    
    def ssl_allowed?
      return true
    end
    
    def prepare_session
      if !session[:expiry_time].nil? and session[:expiry_time] < Time.now
        # Session has expired. Clear the current session.
        reset_session
      end

      # Assign a new expiry time, whether the session has expired or not.
      session[:expiry_time] = 15.minutes.from_now
      return true
    end
    
    def refresh_current_user_session
      response.headers['Cache-Control'] = 'no-cache'
      is_logged_in?
      return true
    end
    
    def is_logged_in?
      begin
        @current_user = User.find(session[:user_id]) if session[:user_id]
      rescue ActiveRecord::RecordNotFound
        return false
      end
    end
    
    def force_login
      unless is_logged_in?
        session[:previous_page] = request.referer
        redirect_to login_users_path
      end
    end
    
    def force_add_email
      if !current_user
        flash[:update] = "You must be logged in as a registered user in order to checkout"
        
        session[:previous_page] = request.referer
        redirect_to register_users_path
        
      elsif !current_user.email
        flash[:update] = "We do not have an email address for you. Please add it."
        session[:previous_page] = request.referer
        redirect_to edit_user_path(current_user.id)
        
      end
    end
    
    def current_user
      @current_user
    end
    
    def current_order
      session_order = {}
      
      if session[:order_id].present?
        begin
          session_order = Order.find(session[:order_id])
          session_order = (session_order.handed_off || session_order.ghost) ? Order.create(:location => "website", :handed_off => false, :staging_type => "purchase") : session_order
        rescue
          session_order = Order.create(:location => "website", :handed_off => false, :staging_type => "purchase")
        end
      else
        session_order = Order.create(:location => "website", :handed_off => false, :staging_type => "purchase")
      end
      
      session[:order_id] = session_order.id
      
      if is_logged_in?
        if current_user.orders.the_living.length > 0 && current_user.orders.the_living.website.open.length > 0
          @order = current_user.orders.the_living.website.open.first
          session_order.line_items.each {|li| @order.line_items << li}
        else
          current_user.orders << session_order
          @order = current_user.orders.the_living.website.open.first
        end
      else
        @order = session_order
      end
      session[:order_id] = @order.id
      return @order
    end
    
    def safe_find(&block)
      begin
        yield
      rescue
        flash[:error] = "We could not find anything like that. Sorry."
      end
    end
end
